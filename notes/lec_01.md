# Lecture 1: Intro to Racket

Racket is:

- a LISP dialect, a quite old lang, name originally standing for "List Processing"

- homoiconic: i.e. uses the same repr for code & data <-- <mark>TODO: come back to this</mark>

- supports functional paradigm, but doesn't enforce it

  - first class fn's
  - hof
  - anon fns

- dynamically & strongly typed

  - allows changing the type of a variable/name
  - has a statically typed variant/superset called `typed racket`

- pass by value, BUT using pointer semantics
  - this means the value passed is the pointer address, not the actual value itself
  - so if a function is given a "value" as an arg, the function body gets it's own reference to the same underlying object
  - this means that the function can modify the object & it will be visible to other variables referencing the same object, but if we change what our reference points to, other references to the original value still point to the original value

- lexically scoped

- heap-based storage w/ gc

A simple Racket program:

```racket markdown-code-runner filename=notes/lec_01/ex_01.rkt
#lang racket

(define (quicksort < l)
  (match l
    ['() '()]
    [(cons x xs)
     (let-values ([(xs-gte xs-lt) (partition (curry < x) xs)])
       (append (quicksort < xs-lt)
               (list x)
               (quicksort < xs-gte)))]))

(quicksort < '(5 3 1 4 2))
```

Running this example gives the following output:

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_01 -->
<!-- racket ex_01.rkt -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
'(1 2 3 4 5)
```

<!-- OUTPUT:END -->

## Syntax

Programs in Racket are entirely composed s-expressions (or "sexp").
An sexp is defined as one of two things:

1. an "atom"

   An atom is a singular data point, such as 

   - numbers (`42`, `-23`, `5/8`, `2+3i`, `6.02e+23`)
   - a value prefixed w/ `#` (booleans #t & #f or chars #\a, #\newline, etc.)
   - a string ("hello world")
   - a Symbol (any identifier of any chars other than `#()[]{}|\'"\`,;`)

2. a "list"

   A list is any sequence of sexps separated by spaces & enclosed by parens, e.g. `(5 4 3 2 1)`.
   Note, `[]` & `{}` can also be used as necessary in place of `()` to help see pairs in a sea of `().`

Some example sexps:

```racket markdown-code-runner filename=notes/lec_01/ex_02.rkt
#lang racket

42                     ;; number
#t                     ;; #prefixed value, boolean
"hello world"          ;; string
(define name "andrew") ;; a list creating a symbol
name                   ;; accessing the value pointed to by that symbol
```

Which when evaluated, return output the following results:

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_01 -->
<!-- racket ex_02.rkt -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
42
#t
"hello world"
"andrew"
```

<!-- OUTPUT:END -->

Note the above example doesn't include a result for our `(define ...)` expression.
This is because the `(define ...)` expression is what is known as a _special form_—something similar to a function call expression, but instead more like a statement.
To bring it back around to why our invocation of the `(define ...)` form didn't return a value—it actually did.
`(define ...)` returns `void` (as do some others), which in racket is typically elided from results (meaning the line is skipped in the lines of returned values).

> INFO: Special forms are actually created by another form, `define-syntax`, and work like a macro.

## Control flow

<mark>TODO...</mark>
