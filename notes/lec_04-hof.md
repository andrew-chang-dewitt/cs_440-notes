higher order functions
============================================================

:::todo
come back to this & fill it out...
:::

```racket markdown-code-runner filename=notes/lec_04-hof/ex_01.rkt
(define (flip f)
  (lambda (a b) (f b a)))

(/ 6 2)
((flip /) 6 2)
(map (curry (flip /) 2) '(1 2 3 4 5 6))
```
<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_01.rkt -->
<!-- tmp="tmp_$file" -->
<!-- echo "#lang racket" | cat - $file > $tmp && mv $tmp $file -->
<!-- racket $file -->
<!-- echo '```' -->
<!-- CODE:END -->

which outputs:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
3
1/3
'(1/2 1 3/2 2 5/2 3)
```

<!-- OUTPUT:END -->

apply
------------------------------------------------------------


list processing
------------------------------------------------------------

a really common use case for hof is processing values in a list. some v useful fn's builtin for this include:

- `map`
- `filter`
- `foldr`
- `foldl`

### `map`

applies a given function to all elements in a list

```racket markdown-code-runner filename=notes/lec_04-hof/ex_02.rkt
(range 10)
(map add1 (range 10))
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_02.rkt -->
<!-- tmp="tmp_$file" -->
<!-- echo "#lang racket" | cat - $file > $tmp && mv $tmp $file -->
<!-- racket $file -->
<!-- echo '```' -->
<!-- CODE:END -->

which outputs:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
'(0 1 2 3 4 5 6 7 8 9)
'(1 2 3 4 5 6 7 8 9 10)
```

<!-- OUTPUT:END -->

### `filter`

returns a new list containing only the values which return true for a given
predicate function

<!-- TODO: finish this example -->
```racket markdown-code-runner filename=notes/lec_04-hof/ex_03.rkt
(range 10)
(map add1 (range 10))
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_03.rkt -->
<!-- tmp="tmp_$file" -->
<!-- echo "#lang racket" | cat - $file > $tmp && mv $tmp $file -->
<!-- racket $file -->
<!-- echo '```' -->
<!-- CODE:END -->

which outputs:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
'(0 1 2 3 4 5 6 7 8 9)
'(1 2 3 4 5 6 7 8 9 10)
```

<!-- OUTPUT:END -->

### `foldr`

beginning from the leftmost value and working to the right, calls a given
function with each value & returning a new value, accumulating to a single
value

we can implement it ourselves using tail recursion:

```racket markdown-code-runner filename=notes/lec_04-hof/ex_04.rkt
(define (foldr f val lst)
  (if (empty? lst)
    val
    (foldr f (f val (first lst)) (rest lst))))
```

<!-- CODE:BASH:START -->
<!-- file=ex_04.rkt -->
<!-- cd notes/lec_04-hof -->
<!-- tmp="tmp_$file" -->
<!-- echo "#lang racket" | cat - $file > $tmp && mv $tmp $file -->
<!-- echo "(provide foldr)" >> $file -->
<!-- CODE:END -->

then if we call it on the list from 0 through 10, summing each value as we go, we see we get 55:

```racket markdown-code-runner filename=notes/lec_04-hof/ex_04a.rkt
(foldr + 0 (range 11))
```

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_04a.rkt -->
<!-- tmp="tmp_$file" -->
<!-- src=ex_04.rkt -->
<!-- echo "#lang racket" >> $tmp -->
<!-- echo "(require \"$src\")" >> $tmp -->
<!-- cat $file >> $tmp && mv $tmp $file -->
<!-- racket $file -->
<!-- echo '```' -->
<!-- CODE:END -->

which outputs:

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
55
```

<!-- OUTPUT:END -->

to see more on how it works, let's trace that invocation:

```racket markdown-code-runner filename=notes/lec_04-hof/ex_04b.rkt
;; (define foldr ...)
(require racket/trace)
(trace foldr)
(foldr + 0 (range 11))
```

<!-- OUTPUT:END -->
<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_04b.rkt -->
<!-- tmp="tmp_$file" -->
<!-- src=ex_04.rkt -->
<!-- cat $src >> $tmp -->
<!-- cat $file >> $tmp -->
<!-- racket $tmp -->
<!-- echo '```' -->
<!-- CODE:END -->

examining the output below, we see that the first invocation takes the starting
value we gave it of 0 & the entire list generated by the `(range ...)`
invocation. then the next iteration takes the same list, but w/out the `0` at
the head of the list. it continues with a new `val` of 1 & the same list
beginnig at `2`, and keeps popping the head & summing it until we arrive at the
final value of `55`.

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```
>(foldr #<procedure:+> 0 '(0 1 2 3 4 5 6 7 8 9 10))
>(foldr #<procedure:+> 0 '(1 2 3 4 5 6 7 8 9 10))
>(foldr #<procedure:+> 1 '(2 3 4 5 6 7 8 9 10))
>(foldr #<procedure:+> 3 '(3 4 5 6 7 8 9 10))
>(foldr #<procedure:+> 6 '(4 5 6 7 8 9 10))
>(foldr #<procedure:+> 10 '(5 6 7 8 9 10))
>(foldr #<procedure:+> 15 '(6 7 8 9 10))
>(foldr #<procedure:+> 21 '(7 8 9 10))
>(foldr #<procedure:+> 28 '(8 9 10))
>(foldr #<procedure:+> 36 '(9 10))
>(foldr #<procedure:+> 45 '(10))
>(foldr #<procedure:+> 55 '())
<55
55
```

<!-- OUTPUT:END -->
<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd notes/lec_04-hof -->
<!-- file=ex_04b.rkt -->
<!-- tmp="tmp_$file" -->
<!-- rm $tmp -->
<!-- echo '```' -->
<!-- CODE:END -->
